{"version":3,"sources":["hickory/hiccup_utils.cljc"],"mappings":"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","names":["hickory.hiccup-utils/first-idx","a","b","x__5133__auto__","y__5134__auto__","var_args","G__10870","hickory.hiccup-utils/index-of","js/Error","s","c","idx","hickory.hiccup-utils/split-keep-trailing-empty","re","clojure.string.split","hickory.hiccup-utils/tag-well-formed?","tag-elem","cljs.core/name","hash-idx","hickory.hiccup_utils.index_of","dot-idx","tag-cutoff","and__5043__auto__","cljs.core.not_EQ_","classes","p1__10872#","cljs.core/every?","cljs.core/count","hickory.hiccup-utils/tag-name","cutoff","hickory.hiccup-utils/class-names","curr-dot","cljs.core/transient","cljs.core/persistent!","next-dot","next-hash","cljs.core.conj_BANG_","hickory.hiccup-utils/id","next-dot-idx","hickory.hiccup-utils/expand-content-seqs","content","remaining-content","result","cljs.core/seq?","cljs.core/first","cljs.core/next","remaining-seq","hickory.hiccup-utils/normalize-element","hiccup-form","vec__10880","seq__10881","cljs.core/seq","first__10882","cljs.core.ex_info","vec__10883","cljs.core.nth","tag-name","cljs.core.keyword","clojure.string/lower-case","tag-classes","tag-id","tag-attrs","cljs.core/empty?","clojure.string.join","map-attrs","cljs.core/map?","cljs.core/rest","attrs","cljs.core.merge","cljs.core.apply","cljs.core/vector","hickory.hiccup-utils/normalize-form","form","vec__10890","seq__10891","first__10892","tag","contents","p1__10886#","cljs.core.map","cljs.core/vector?"],"sourcesContent":["(ns hickory.hiccup-utils\n  \"Utilities for working with hiccup forms.\"\n  (:require [clojure.string :as str]))\n\n(defn- first-idx\n  \"Given two possible indexes, returns the lesser that is not -1. If both\n   are -1, then -1 is returned. Useful for searching strings for multiple\n   markers, as many routines will return -1 for not found.\n\n   Examples: (first-idx -1 -1) => -1\n             (first-idx -1 2) => 2\n             (first-idx 5 -1) => 5\n             (first-idx 5 3) => 3\"\n  #?(:clj  [^long a ^long b]\n     :cljs [a b])\n  (if (== a -1)\n    b\n    (if (== b -1)\n      a\n      (min a b))))\n\n(defn- index-of\n  ([^String s c]\n    #?(:clj  (.indexOf s (int c))\n       :cljs (.indexOf s c)))\n  ([^String s c idx]\n    #?(:clj  (.indexOf s (int c) (int idx))\n       :cljs (.indexOf s c idx))))\n\n(defn- split-keep-trailing-empty\n  \"clojure.string/split is a wrapper on java.lang.String/split with the limit\n   parameter equal to 0, which keeps leading empty strings, but discards\n   trailing empty strings. This makes no sense, so we have to write our own\n   to keep the trailing empty strings.\"\n  [s re]\n  (str/split s re -1))\n\n(defn tag-well-formed?\n  \"Given a hiccup tag element, returns true iff the tag is in 'valid' hiccup\n   format. Which in this function means:\n      1. Tag name is non-empty.\n      2. If there is an id, there is only one.\n      3. If there is an id, it is nonempty.\n      4. If there is an id, it comes before any classes.\n      5. Any class name is nonempty.\"\n  [tag-elem]\n  (let [tag-elem (name tag-elem)\n        hash-idx (int (index-of tag-elem \\#))\n        dot-idx (int (index-of tag-elem \\.))\n        tag-cutoff (first-idx hash-idx dot-idx)]\n    (and (< 0 (count tag-elem)) ;; 1.\n         (if (== tag-cutoff -1) true (> tag-cutoff 0)) ;; 1.\n         (if (== hash-idx -1)\n           true\n           (and (== -1 (index-of tag-elem \\# (inc hash-idx))) ;; 2.\n                (< (inc hash-idx) (first-idx (index-of tag-elem \\. ;; 3.\n                                                       (inc hash-idx))\n                                             (count tag-elem)))))\n         (if (and (not= hash-idx -1) (not= dot-idx -1)) ;; 4.\n           (< hash-idx dot-idx)\n           true)\n         (if (== dot-idx -1) ;; 5.\n           true\n           (let [classes (.substring tag-elem (inc dot-idx))]\n             (every? #(< 0 (count %))\n                     (split-keep-trailing-empty classes #\"\\.\")))))))\n\n(defn tag-name\n  \"Given a well-formed hiccup tag element, return just the tag name as\n  a string.\"\n  [tag-elem]\n  (let [tag-elem (name tag-elem)\n        hash-idx (int (index-of tag-elem \\#))\n        dot-idx (int (index-of tag-elem \\.))\n        cutoff (first-idx hash-idx dot-idx)]\n    (if (== cutoff -1)\n      ;; No classes or ids, so the entire tag-element is the name.\n      tag-elem\n      ;; There was a class or id, so the tag name ends at the first\n      ;; of those.\n      (.substring tag-elem 0 cutoff))))\n\n(defn class-names\n  \"Given a well-formed hiccup tag element, return a vector containing\n   any class names included in the tag, as strings. Ignores the hiccup\n   requirement that any id on the tag must come\n   first. Example: :div.foo.bar => [\\\"foo\\\" \\\"bar\\\"].\"\n  [tag-elem]\n  (let [tag-elem (name tag-elem)]\n    (loop [curr-dot (index-of tag-elem \\.)\n           classes (transient [])]\n      (if (== curr-dot -1)\n        ;; Didn't find another dot, so no more classes.\n        (persistent! classes)\n        ;; There's another dot, so there's another class.\n        (let [next-dot (index-of tag-elem \\. (inc curr-dot))\n              next-hash (index-of tag-elem \\# (inc curr-dot))\n              cutoff (first-idx next-dot next-hash)]\n          (if (== cutoff -1)\n            ;; Rest of the tag element is the last class.\n            (recur next-dot\n                   (conj! classes (.substring tag-elem (inc curr-dot))))\n            ;; The current class name is terminated by another element.\n            (recur next-dot\n                   (conj! classes\n                          (.substring tag-elem (inc curr-dot) cutoff)))))))))\n\n(defn id\n  \"Given a well-formed hiccup tag element, return a string containing\n   the id, or nil if there isn't one.\"\n  [tag-elem]\n  (let [tag-elem (name tag-elem)\n        hash-idx (int (index-of tag-elem \\#))\n        next-dot-idx (int (index-of tag-elem \\. hash-idx))]\n    (if (== hash-idx -1)\n      nil\n      (if (== next-dot-idx -1)\n        (.substring tag-elem (inc hash-idx))\n        (.substring tag-elem (inc hash-idx) next-dot-idx)))))\n\n(defn- expand-content-seqs\n  \"Given a sequence of hiccup forms, presumably the content forms of another\n   hiccup element, return a new sequence with any sequence elements expanded\n   into the main sequence. This logic does not apply recursively, so sequences\n   inside sequences won't be expanded out. Also note that this really only\n   applies to sequences; things that seq? returns true on. So this excludes\n   vectors.\n     (expand-content-seqs [1 '(2 3) (for [x [1 2 3]] (* x 2)) [5]])\n     ==> (1 2 3 2 4 6 [5])\"\n  [content]\n  (loop [remaining-content content\n         result (transient [])]\n    (if (nil? remaining-content)\n      (persistent! result)\n      (if (seq? (first remaining-content))\n        (recur (next remaining-content)\n               ;; Fairly unhappy with this nested loop, but it seems\n               ;; necessary to continue the handling of transient vector.\n               (loop [remaining-seq (first remaining-content)\n                      result result]\n                 (if (nil? remaining-seq)\n                   result\n                   (recur (next remaining-seq)\n                          (conj! result (first remaining-seq))))))\n        (recur (next remaining-content)\n               (conj! result (first remaining-content)))))))\n\n(defn- normalize-element\n  \"Given a well-formed hiccup form, ensure that it is in the form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Note that this\n   does not happen recursively; content is not modified.\"\n  [hiccup-form]\n  (let [[tag-elem & content] hiccup-form]\n    (when (not (tag-well-formed? tag-elem))\n      (throw (ex-info (str \"Invalid input: Tag element\"\n                           tag-elem \"is not well-formed.\")\n                      {})))\n    (let [tag-name (keyword (str/lower-case (tag-name tag-elem)))\n          tag-classes (class-names tag-elem)\n          tag-id (id tag-elem)\n          tag-attrs {:id tag-id\n                     :class (if (not (empty? tag-classes))\n                              (str/join \" \" tag-classes))}\n          [map-attrs content] (if (map? (first content))\n                                [(first content) (rest content)]\n                                [nil content])\n          ;; Note that we replace tag attributes with map attributes, without\n          ;; merging them. This is to match hiccup's behavior.\n          attrs (merge tag-attrs map-attrs)]\n      (apply vector tag-name attrs content))))\n\n(defn normalize-form\n  \"Given a well-formed hiccup form, recursively normalizes it, so that it and\n   all children elements will also be normalized. A normalized form is in the\n   form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Any content\n   that is a sequence is also expanded out into the main sequence of content\n   items.\"\n  [form]\n  (if (string? form)\n    form\n    ;; Do a pre-order walk and save the first two items, then do the children,\n    ;; then glue them back together.\n    (let [[tag attrs & contents] (normalize-element form)]\n      (apply vector tag attrs (map #(if (vector? %)\n                                      ;; Recurse only on vec children.\n                                      (normalize-form %)\n                                      %)\n                                   (expand-content-seqs contents))))))\n"]}