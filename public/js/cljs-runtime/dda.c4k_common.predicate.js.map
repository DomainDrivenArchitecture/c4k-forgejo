{"version":3,"sources":["dda/c4k_common/predicate.cljc"],"mappings":";AAMA,kDAAA,lDAAMA,4GACHC;AADH,AAEE,SAAK,OAASA,wBACT,AAACC,cAAI,qBAAA,rBAACC,oCAA2BF;;AAExC,8CAAA,9CAAMG,oGACHH;AADH,AAEE,SAAK,OAASA,wBACT,GAAA,0GAAA,zGAAO,qBAAA,rBAACE,+FAAsFF;;AAErG,yDAAA,zDAAMI,0HACHC,cAAcC,UAAUN;AAD3B,AAEE,OAACO,uBAAOC,sBAAM,AAACC,4CAAIJ,cAAc,AAACK,mDAAUV,MAAMM;;AAEpD,qDAAA,rDAAMK,kHACHX;AADH,AAEE,iCAAA,iFAAA,eAAA,1HAACY,qJAA8BZ;;AAEjC,wCAAA,xCAAMa,wFACHb;AADH,AAEE,iCAAA,iFAAA,WAAA,YAAA,WAAA,WAAA,xJAACY,mLAA6CZ;;AAEhD,6CAAA,7CAAMc,kGACHd;AADH,AAEE,SAAI,AAACe,qBAAKf,YACN,AAACgB,qBAAKhB;;AAEZ,yDAAA,zDAAMiB,0HACHjB;AADH,AAEE,iCAAA,iFAAA,kBAAA,7HAACY,0JAAmCZ;;AAEtC,8CAAA,9CAAMkB,oGACHlB;AADH,AAEE,8CAAA,rCAAK,AAACmB,yBAASnB,cACV,SAAA,RAAGA,kBACH,UAAA,TAAIA;;AAEX,uDAAA,vDAAMoB,sHACHpB;AADH,AAEE,IAAAqB,oBAAK,OAASrB;AAAd,AAAA,GAAAqB;AACK,IAAMC,eAAa,yDAAA,zDAACZ,mDAAUV;AAA9B,AACE,8FAAA,rFAAK,2EAAA,3EAACuB,6CAAE,AAACC,gBAAMF,0BACV,AAACnB,4CAAa,AAACsB,gBAAMH,oBACrB,AAACJ,4CAAa,AAACQ,sDAAgB,AAACC,iBAAOL;;AAJnDD;;;AAMF,iDAAA,jDAAMO,0GACH5B;AADH,AAEE,wCAAA,/BAAK,OAASA,0BACT,GAAA,wCAAA,vCAAO,qBAAA,rBAACE,6BAAoBF,uBAC5B,AAACmB,yBAAS,AAACO,sDAAgB1B;;AAElC,kDAAA,lDAAM6B,4GACH7B;AADH,AAEE,SAAK,AAAC8B,4BAAY9B,YACb,AAACO,uBAAOC,sBACA,4CAAA,WAAAuB,vDAACtB;AAAD,AAAM,cAAAsB;GAAY/B;;AAEjC,2CAAA,3CAAMgC,8FACHC,EAAEjC;AADL,AAEE,SAAK,AAACkC,qBAAKlC,YACN,CAAGA,QAAMiC;;AAEhB,gDAAA,hDAAME,wGACHnC;AADH,AAEE,SACC,OAASA,wBACT,OAASA","names":["dda.c4k-common.predicate/bash-env-string?","input","cljs.core/not","cljs.core/re-matches","dda.c4k-common.predicate/fqdn-string?","dda.c4k-common.predicate/string-of-separated-by?","spec-function","separator","cljs.core/every?","cljs.core/true?","cljs.core.map","clojure.string.split","dda.c4k-common.predicate/letsencrypt-issuer?","cljs.core/contains?","dda.c4k-common.predicate/stage?","dda.c4k-common.predicate/map-or-seq?","cljs.core/map?","cljs.core/seq?","dda.c4k-common.predicate/pvc-storage-class-name?","dda.c4k-common.predicate/port-number?","cljs.core/integer?","dda.c4k-common.predicate/host-and-port-string?","and__5043__auto__","split-string","cljs.core._EQ_","cljs.core/count","cljs.core/first","cljs.reader.read_string","cljs.core/second","dda.c4k-common.predicate/integer-string?","dda.c4k-common.predicate/string-sequence?","cljs.core/sequential?","p1__6159#","dda.c4k-common.predicate/int-gt-n?","n","cljs.core/int?","dda.c4k-common.predicate/str-or-number?"],"sourcesContent":["(ns dda.c4k-common.predicate\n  (:require\n   [clojure.string :as str]\n   #?(:clj [clojure.edn :as edn]\n      :cljs [cljs.reader :as edn])))\n\n(defn bash-env-string?\n  [input]\n  (and (string? input)\n       (not (re-matches #\".*['\\\"\\$]+.*\" input))))\n\n(defn fqdn-string?\n  [input]\n  (and (string? input)\n       (some? (re-matches #\"(?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{0,62}[a-zA-Z0-9]\\.)+[a-zA-Z]{2,63}$)\" input))))\n\n(defn string-of-separated-by?\n  [spec-function separator input]\n  (every? true? (map spec-function (str/split input separator))))\n\n(defn letsencrypt-issuer?\n  [input]\n  (contains? #{\"prod\" \"staging\"} input))\n\n(defn stage?\n  [input]\n  (contains? #{\"prod\" \"acc\" \"int\" \"test\" \"dev\"} input))\n\n(defn map-or-seq?\n  [input]\n  (or (map? input) \n      (seq? input)))\n\n(defn pvc-storage-class-name?\n  [input]\n  (contains? #{\"manual\" \"local-path\"} input))\n\n(defn port-number?\n  [input]\n  (and (integer? input)\n       (> input 0)\n       (<= input 65535)))\n\n(defn host-and-port-string?\n  [input]\n  (and (string? input)\n       (let [split-string (str/split input #\":\")]\n         (and (= (count split-string) 2)\n              (fqdn-string? (first split-string))\n              (port-number? (edn/read-string (second split-string)))))))\n\n(defn integer-string?\n  [input]\n  (and (string? input)\n       (some? (re-matches #\"^\\d+$\" input))\n       (integer? (edn/read-string input))))\n\n(defn string-sequence?\n  [input]\n  (and (sequential? input)\n       (every? true?\n               (map #(string? %) input))))\n\n(defn int-gt-n?\n  [n input]\n  (and (int? input)\n       (> input n)))\n\n(defn str-or-number? \n  [input]\n  (or \n   (string? input) \n   (number? input)))\n\n"]}